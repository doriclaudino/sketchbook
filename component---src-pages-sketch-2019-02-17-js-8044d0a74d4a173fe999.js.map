{"version":3,"sources":["webpack:///./src/lib/addNoise.js","webpack:///./src/pages/sketch/2019/02/17.js"],"names":["addNoise","p","intensity","PTS","width","height","push","i","fill","noStroke","ellipse","randomGaussian","pixelDensity","pop","sketch","points","getVectors","position","createVector","velocity","random","acceleration","setup","createCanvas","Array","map","_","background","draw","forEach","add","x","y","points2","reached","shortest","dist","reachedIndex","unreachedIndex","point","point2","i2","THIS_DIST","stroke","cos","frameCount","line","filter","length","noLoop","location","path","pathname"],"mappings":"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","file":"component---src-pages-sketch-2019-02-17-js-8044d0a74d4a173fe999.js","sourcesContent":["const addNoise = (p, intensity = 0.5) => {\n  const PTS = p.width * p.height * 0.02;\n\n  p.push();\n  for (let i = 0; i < PTS; i++) {\n    p.fill(\n      i % 2\n        ? `rgba(0, 0, 0, ${intensity})`\n        : `rgba(255, 255, 255, ${intensity})`\n    );\n    p.noStroke();\n    p.ellipse(\n      p.randomGaussian(p.width / 2, p.width / 3),\n      p.randomGaussian(p.height / 2, p.height / 3),\n      1 / (p.pixelDensity() / 2)\n    );\n  }\n  p.pop();\n};\n\nexport default addNoise;\n","import React from \"react\";\r\nimport SketchLayout from \"~components/sketch-layout\";\r\nimport addNoise from \"~lib/addNoise\";\r\n\r\nconst sketch = function(p) {\r\n  let points = [];\r\n\r\n  function getVectors() {\r\n    return {\r\n      position: p.createVector(\r\n        p.randomGaussian(p.width / 2, p.width / 15),\r\n        p.randomGaussian(p.height / 2, p.height / 15)\r\n      ),\r\n      velocity: p.createVector(p.random(-0.1, 0.1), p.random(-0.1, 0.1)),\r\n      acceleration: p.createVector(p.random(-0.1, 0.1), p.random(-0.1, 0.1)),\r\n    };\r\n  }\r\n\r\n  p.setup = function() {\r\n    p.createCanvas(660, 840);\r\n    points = new Array(50).fill().map(_ => getVectors());\r\n    p.background(0);\r\n  };\r\n\r\n  p.draw = function() {\r\n    points.forEach(({ position, velocity, acceleration }, i) => {\r\n      points[i].position = position.add(velocity.add(acceleration));\r\n      if (\r\n        position.x < 0 ||\r\n        position.x > p.width ||\r\n        position.y < 0 ||\r\n        position.y > p.height\r\n      ) {\r\n        points[i] = getVectors();\r\n      }\r\n    });\r\n    let points2 = points.map(p => ({\r\n      position: p.position,\r\n      reached: false,\r\n    }));\r\n    points2[0].reached = true;\r\n    while (points2.filter(point => point.reached).length < points2.length) {\r\n      const MAX = p.dist(0, 0, p.width, p.height) * 2;\r\n      let shortest = MAX;\r\n      let reachedIndex;\r\n      let unreachedIndex;\r\n      points2.forEach((point, i) => {\r\n        if (!point.reached) return;\r\n        points2.forEach((point2, i2) => {\r\n          if (point2.reached) return;\r\n          const THIS_DIST = p.dist(\r\n            point.position.x,\r\n            point.position.y,\r\n            point2.position.x,\r\n            point2.position.y\r\n          );\r\n          if (THIS_DIST < shortest) {\r\n            shortest = THIS_DIST;\r\n            reachedIndex = i;\r\n            unreachedIndex = i2;\r\n          }\r\n        });\r\n      });\r\n      p.stroke(\r\n        255 * p.cos(p.frameCount / 100),\r\n        p.map(\r\n          p.dist(\r\n            p.width / 2,\r\n            p.height / 2,\r\n            points2[unreachedIndex].position.x,\r\n            points2[unreachedIndex].position.y\r\n          ),\r\n          0,\r\n          p.dist(0, 0, p.width / 2, p.height / 2),\r\n          64,\r\n          0\r\n        )\r\n      );\r\n      p.line(\r\n        points2[reachedIndex].position.x,\r\n        points2[reachedIndex].position.y,\r\n        points2[unreachedIndex].position.x,\r\n        points2[unreachedIndex].position.y\r\n      );\r\n      points2[unreachedIndex].reached = true;\r\n    }\r\n    addNoise(p, 0.02);\r\n    if (p.frameCount > 800) {\r\n      p.noLoop();\r\n    }\r\n  };\r\n};\r\n\r\nexport default ({ location }) => (\r\n  <SketchLayout sketch={sketch} path={location.pathname} />\r\n);\r\n"],"sourceRoot":""}