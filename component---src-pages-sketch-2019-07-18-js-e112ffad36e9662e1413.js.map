{"version":3,"sources":["webpack:///./src/pages/sketch/2019/07/18.js","webpack:///./src/lib/polarToCartesian.js"],"names":["sketch","p","HUE","random","aElement","i","aPosition","setup","createCanvas","colorMode","HSL","background","noFill","blendMode","OVERLAY","ellipseMode","CENTER","draw","NOISE","noise","frameCount","push","stroke","map","cos","sin","translate","polarToCartesian","width","height","rotate","arc","PI","pop","TWO_PI","console","log","HALF_PI","noLoop","location","path","pathname","description","polarToCartesianX","center","angle","distance","Math","polarToCartesianY","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y"],"mappings":"mjBAIA,IAAMA,EAAS,SAASC,GACtB,IAAMC,EAAMD,EAAEE,OAAO,IAIjBC,EAAW,EACXC,EAAI,EACJC,EAAY,EAEhBL,EAAEM,MAAQ,WACRN,EAAEO,aAAa,IAAK,KACpBP,EAAEQ,UAAUR,EAAES,IAAK,KACnBT,EAAEU,WAAWT,EAAK,GAAI,IACtBD,EAAEW,SACFX,EAAEY,UAAUZ,EAAEa,SACdb,EAAEc,YAAYd,EAAEe,SAGlBf,EAAEgB,KAAO,WACP,IAAMC,EAAQjB,EAAEkB,MAAMlB,EAAEmB,WAAF,KAAmCd,GAEzDL,EAAEoB,OACFpB,EAAEqB,OACArB,EAAEsB,IAAItB,EAAEuB,IAAIvB,EAAEmB,WAAF,MAAoC,EAAG,EAAGlB,EAAKA,EAAM,IACjE,GACAD,EAAEsB,IAAItB,EAAEwB,IAAInB,IAAa,EAAG,EAAG,GAAI,IACnC,IAAM,EAAIY,IAEZjB,EAAEyB,UAAF,MAAAzB,EAAC,EACI0B,YACD1B,EAAE2B,MAAQ,EACV3B,EAAE4B,OAAS,EACXvB,EACCL,EAAE2B,MAAQ,EAAKV,GAChB,KAGJjB,EAAE6B,OAAO1B,GACTH,EAAE8B,IACA,EACA,EACA9B,EAAE2B,MAAQV,EACV,GACAjB,EAAEmB,WAzCa,GA0CfnB,EAAEmB,WA1Ca,GA0CanB,EAAE+B,IAEhC/B,EAAEgC,MACF3B,GAAaL,EAAEiC,OA5CH,IA8CZC,QAAQC,IAAI/B,GAEZD,GAAYH,EAAEoC,QAAF,MACR/B,EAAYL,EAAEiC,SAChB5B,EAAY,IACZD,EApDe,KAsDbJ,EAAEqC,SACFH,QAAQC,IAAI,YAML,0BAAGG,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAcvC,OAAQA,EAAQwC,KAAMD,EAASE,SAAUC,YAAY,O,kCCpErE,0GAAMC,EAAoB,SAACC,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKvB,IAAIqB,GAASC,GAE9BE,EAAoB,SAACJ,EAAQC,EAAOC,GACxC,OAAOF,EAASG,KAAKtB,IAAIoB,GAASC,GAa9BG,EAA0B,SAC9BC,EACAC,EACAN,EACAO,EACAC,EACAC,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIL,EAAUH,KAAKvB,IAAIqB,GAASO,EAChCI,EAAIL,EAAUJ,KAAKtB,IAAIoB,GAASQ,EACtC,OAAOC,EAAU,CAACC,EAAGC,GAAK,CAAED,IAAGC,MAIlB7B,IAzBU,SACvBuB,EACAC,EACAN,EACAC,EACAQ,QACG,IADHA,OAAU,GAEV,IAAMC,EAAIZ,EAAkBO,EAASL,EAAOC,GACtCU,EAAIR,EAAkBG,EAASN,EAAOC,GAC5C,OAAOQ,EAAU,CAACC,EAAGC,GAAK,CAAED,IAAGC","file":"component---src-pages-sketch-2019-07-18-js-e112ffad36e9662e1413.js","sourcesContent":["import React from \"react\";\r\nimport SketchLayout from \"~components/sketch-layout\";\r\nimport polarToCartesian from \"~lib/polarToCartesian\";\r\n\r\nconst sketch = function(p) {\r\n  const HUE = p.random(80);\r\n  const ITERATIONS = 15;\r\n  const COUNT = 720;\r\n\r\n  let aElement = 0;\r\n  let i = 1;\r\n  let aPosition = 0;\r\n\r\n  p.setup = function() {\r\n    p.createCanvas(660, 840);\r\n    p.colorMode(p.HSL, 100);\r\n    p.background(HUE, 30, 80);\r\n    p.noFill();\r\n    p.blendMode(p.OVERLAY);\r\n    p.ellipseMode(p.CENTER);\r\n  };\r\n\r\n  p.draw = function() {\r\n    const NOISE = p.noise(p.frameCount / (ITERATIONS * 100), aPosition);\r\n\r\n    p.push();\r\n    p.stroke(\r\n      p.map(p.cos(p.frameCount / (ITERATIONS * 10)), -1, 1, HUE, HUE + 20),\r\n      50,\r\n      p.map(p.sin(aPosition), -1, 1, 90, 25),\r\n      20 * (1 - NOISE)\r\n    );\r\n    p.translate(\r\n      ...polarToCartesian(\r\n        p.width / 2,\r\n        p.height / 2,\r\n        aPosition,\r\n        (p.width / 3) * NOISE,\r\n        true\r\n      )\r\n    );\r\n    p.rotate(aElement);\r\n    p.arc(\r\n      0,\r\n      0,\r\n      p.width * NOISE,\r\n      50,\r\n      p.frameCount / ITERATIONS,\r\n      p.frameCount / ITERATIONS + p.PI\r\n    );\r\n    p.pop();\r\n    aPosition += p.TWO_PI / COUNT;\r\n\r\n    console.log(i);\r\n\r\n    aElement -= p.HALF_PI / (COUNT * ITERATIONS);\r\n    if (aPosition > p.TWO_PI) {\r\n      aPosition = 0;\r\n      i++;\r\n      if (i > ITERATIONS) {\r\n        p.noLoop();\r\n        console.log(\"done\");\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\nexport default ({ location }) => (\r\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\r\n);\r\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n"],"sourceRoot":""}