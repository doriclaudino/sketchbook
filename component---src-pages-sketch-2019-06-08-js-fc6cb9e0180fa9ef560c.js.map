{"version":3,"sources":["webpack:///./src/lib/polarToCartesian.js","webpack:///./src/pages/sketch/2019/06/08.js"],"names":["polarToCartesianX","center","angle","distance","Math","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","x","y","polarToCartesian","sketch","p","HUE","random","vertices","Vertex","this","TWO_PI","height","speed","get","width","update","setup","createCanvas","noStroke","colorMode","HSL","background","Array","from","draw","vs","filter","clr","color","map","frameCount","length","noFill","stroke","line","fill","beginShape","sort","a","b","forEach","v","vertex","endShape","CLOSE","noLoop","location","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2019-06-08-js-fc6cb9e0180fa9ef560c.js","sourcesContent":["const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","import React from \"react\";\r\nimport SketchLayout from \"~components/sketch-layout\";\r\nimport polarToCartesian from \"~lib/polarToCartesian\";\r\n\r\nconst sketch = function(p) {\r\n  const HUE = p.random(80);\r\n  const V_QTY = 10;\r\n\r\n  let vertices = [];\r\n\r\n  class Vertex {\r\n    constructor() {\r\n      this.angle = p.random(p.TWO_PI);\r\n      this.distance = p.random(p.height * (2 / 3));\r\n      this.speed = p.random([-1, 1]) * p.random(0.0001, 0.001);\r\n    }\r\n    get() {\r\n      return polarToCartesian(\r\n        p.width / 2,\r\n        p.height / 2,\r\n        this.angle,\r\n        this.distance,\r\n        true\r\n      );\r\n    }\r\n    update() {\r\n      this.angle += this.speed;\r\n      if (this.angle < 0) {\r\n        this.angle = p.TWO_PI + this.angle;\r\n      }\r\n      if (this.angle > p.TWO_PI) {\r\n        this.angle = this.angle - p.TWO_PI;\r\n      }\r\n      this.distance = this.distance > 0 ? this.distance - 0.03 : 0;\r\n    }\r\n  }\r\n\r\n  p.setup = function() {\r\n    p.createCanvas(660, 840);\r\n    p.noStroke();\r\n    p.colorMode(p.HSL, 100);\r\n    p.background(HUE, 100, 0);\r\n\r\n    vertices = Array.from(Array(V_QTY), () => new Vertex());\r\n  };\r\n\r\n  p.draw = function() {\r\n    const vs = vertices.filter(({ distance }) => distance > 0);\r\n    const clr = p.color(\r\n      p.map(p.cos(p.frameCount / 1000), -1, 1, HUE, HUE + 20),\r\n      p.map(p.sin(p.frameCount / 50), -1, 1, 80, 100),\r\n      p.map(p.cos(p.frameCount / 500), -1, 1, 0, 100),\r\n      80\r\n    );\r\n\r\n    if (vs.length === 1) {\r\n      p.noLoop();\r\n      return;\r\n    }\r\n\r\n    if (vs.length === 2) {\r\n      p.noFill();\r\n      p.stroke(clr);\r\n      p.line(...vs[0].get(), ...vs[1].get());\r\n      vs[0].update();\r\n      vs[1].update();\r\n    } else {\r\n      p.noStroke();\r\n      p.fill(clr);\r\n      p.beginShape();\r\n      vs.sort((a, b) => a.angle - b.angle).forEach(v => {\r\n        p.vertex(...v.get());\r\n        v.update();\r\n      });\r\n      p.endShape(p.CLOSE);\r\n    }\r\n  };\r\n};\r\n\r\nexport default ({ location }) => (\r\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\r\n);\r\n"],"sourceRoot":""}