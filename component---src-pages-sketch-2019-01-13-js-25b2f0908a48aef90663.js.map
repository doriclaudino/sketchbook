{"version":3,"sources":["webpack:///./src/pages/sketch/2019/01/13.js"],"names":["sketch","p","maxDist","gridSize","vectors","setup","pixelDensity","createCanvas","floor","random","x","y","xc","width","yc","height","dist","push","vector","createVector","reached","reachedBy","background","strokeWeight","fill","draw","ellipse","stroke","filter","v","forEach","point","pop","reachedByIndex","unreachedIndex","shortestDist","uv","ui","rv","ri","thisDist","i","noFill","line","triangle","length","noLoop","location","path","pathname","description"],"mappings":"mJAGMA,EAAS,SAASC,GACtB,IACIC,EACAC,EAFAC,EAAU,GAKdH,EAAEI,MAAQ,WACRJ,EAAEK,aAAa,GACfL,EAAEM,aAAa,IAAK,KACpBJ,EAAWF,EAAEO,MAAMP,EAAEQ,OAAO,GAAI,KAChC,IAAK,IAAIC,EAAI,EAAGA,GAAKP,EAAUO,IAC7B,IAAK,IAAIC,EAAI,EAAGA,GAAKR,EAAUQ,IAAK,CAClC,IAAMC,EAAKX,EAAEO,MAAOP,EAAEY,MAAQV,EAAYO,GACpCI,EAAKb,EAAEO,MAAOP,EAAEc,OAASZ,EAAYQ,GAEzCV,EAAEe,KAAKJ,EAAIE,EAAIb,EAAEY,MAAQ,EAAGZ,EAAEc,OAAS,GAAKd,EAAEY,MAAQ,EAAI,KAC1DZ,EAAEQ,SAAW,IAEbL,EAAQa,KAAK,CACXC,OAAQjB,EAAEkB,aAAaP,EAAIE,GAC3BM,SAAS,EACTC,UAAW,IAKnBjB,EAAQ,GAAGgB,SAAU,EACrBhB,EAAQ,GAAGiB,WAAa,EACxBnB,EAAUD,EAAEe,KAAK,EAAG,EAAGf,EAAEY,MAAOZ,EAAEc,QAClCd,EAAEqB,WAAW,GACbrB,EAAEsB,aAAa,GACftB,EAAEuB,KAAK,IAGTvB,EAAEwB,KAAO,WACPxB,EAAEuB,KAAK,KACPvB,EAAEyB,QACAzB,EAAEY,MAAQ,EACVZ,EAAEc,OAAS,EACXd,EAAEY,MAAQ,EAAI,IAAOZ,EAAEY,MAAQV,EAAY,GAE7CF,EAAEgB,OACFhB,EAAE0B,OAAkB,OACpBvB,EACGwB,QAAO,SAAAC,GAAC,OAAKA,EAAET,WACfU,SAAQ,gBAAGZ,EAAH,EAAGA,OAAH,OAAgBjB,EAAE8B,MAAMb,EAAOR,EAAGQ,EAAOP,MACpDV,EAAE+B,MACF,IACIC,EACAC,EAFAC,EAAejC,EAGnBE,EAAQ0B,SAAQ,SAACM,EAAIC,GACdD,EAAGhB,SACNhB,EAAQ0B,SAAQ,SAACQ,EAAIC,GACnB,GAAID,EAAGlB,QAAS,CACd,IAAMoB,EAAWvC,EAAEe,KACjBoB,EAAGlB,OAAOR,EACV0B,EAAGlB,OAAOP,EACV2B,EAAGpB,OAAOR,EACV4B,EAAGpB,OAAOP,GAER6B,EAAWL,IACbA,EAAeK,EACfN,EAAiBG,EACjBJ,EAAiBM,UAM3BnC,EAAQ8B,GAAgBd,SAAU,EAClChB,EAAQ8B,GAAgBb,UAAYY,EAEpC7B,EAAQ0B,SAAQ,WAAiCW,GAAO,IAArCvB,EAAoC,EAApCA,OAAQE,EAA4B,EAA5BA,QAASC,EAAmB,EAAnBA,UAClC,GAAID,GAAWC,GAAa,EAAG,CAAC,IAAD,EACZjB,EAAQiB,GAAWH,OAA5BR,EADqB,EACrBA,EAAGC,EADkB,EAClBA,EACXV,EAAE0B,OAAO,GACT1B,EAAEsB,aAAa,GACftB,EAAEyC,SACFzC,EAAE0C,KAAKzB,EAAOR,EAAGQ,EAAOP,EAAGD,EAAGC,GAC9BV,EAAEuB,KAAK,GACPvB,EAAEsB,aAAa,GACftB,EAAE2C,SAAS1B,EAAOR,EAAGQ,EAAOP,EAAGD,EAAGC,EAAGD,EAAGQ,EAAOP,GAC1CO,EAAOR,IAAMA,GAAKQ,EAAOP,IAAMA,GAAM8B,EAAI,GAAM,GAClDxC,EAAEyB,QAAQhB,EAAGC,EAAGV,EAAEe,KAAKN,EAAGC,EAAGO,EAAOR,EAAGQ,EAAOP,QAIhDP,EAAQwB,QAAO,SAAAC,GAAC,OAAIA,EAAET,WAASyB,SAAWzC,EAAQyC,QACpD5C,EAAE6C,WAKO,0BAAGC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAc/C,OAAQA,EAAQgD,KAAMD,EAASE,SAAUC,YAAY","file":"component---src-pages-sketch-2019-01-13-js-25b2f0908a48aef90663.js","sourcesContent":["import React from \"react\";\r\nimport SketchLayout from \"~components/sketch-layout\";\r\n\r\nconst sketch = function(p) {\r\n  let vectors = [];\r\n  let maxDist;\r\n  let gridSize;\r\n  let showDots = true;\r\n\r\n  p.setup = function() {\r\n    p.pixelDensity(1);\r\n    p.createCanvas(660, 840);\r\n    gridSize = p.floor(p.random(25, 50));\r\n    for (let x = 0; x <= gridSize; x++) {\r\n      for (let y = 0; y <= gridSize; y++) {\r\n        const xc = p.floor((p.width / gridSize) * x);\r\n        const yc = p.floor((p.height / gridSize) * y);\r\n        if (\r\n          p.dist(xc, yc, p.width / 2, p.height / 2) < p.width / 2 - 100 &&\r\n          p.random() < 0.5\r\n        ) {\r\n          vectors.push({\r\n            vector: p.createVector(xc, yc),\r\n            reached: false,\r\n            reachedBy: 0,\r\n          });\r\n        }\r\n      }\r\n    }\r\n    vectors[0].reached = true;\r\n    vectors[0].reachedBy = -1;\r\n    maxDist = p.dist(0, 0, p.width, p.height);\r\n    p.background(0);\r\n    p.strokeWeight(2);\r\n    p.fill(0);\r\n  };\r\n\r\n  p.draw = function() {\r\n    p.fill(255);\r\n    p.ellipse(\r\n      p.width / 2,\r\n      p.height / 2,\r\n      p.width / 2 + 100 + (p.width / gridSize) * 8\r\n    );\r\n    p.push();\r\n    p.stroke(showDots ? \"red\" : 255);\r\n    vectors\r\n      .filter(v => !v.reached)\r\n      .forEach(({ vector }) => p.point(vector.x, vector.y));\r\n    p.pop();\r\n    let shortestDist = maxDist;\r\n    let reachedByIndex;\r\n    let unreachedIndex;\r\n    vectors.forEach((uv, ui) => {\r\n      if (!uv.reached) {\r\n        vectors.forEach((rv, ri) => {\r\n          if (rv.reached) {\r\n            const thisDist = p.dist(\r\n              uv.vector.x,\r\n              uv.vector.y,\r\n              rv.vector.x,\r\n              rv.vector.y\r\n            );\r\n            if (thisDist < shortestDist) {\r\n              shortestDist = thisDist;\r\n              unreachedIndex = ui;\r\n              reachedByIndex = ri;\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n    vectors[unreachedIndex].reached = true;\r\n    vectors[unreachedIndex].reachedBy = reachedByIndex;\r\n\r\n    vectors.forEach(({ vector, reached, reachedBy }, i) => {\r\n      if (reached && reachedBy > -1) {\r\n        const { x, y } = vectors[reachedBy].vector;\r\n        p.stroke(0);\r\n        p.strokeWeight(2);\r\n        p.noFill();\r\n        p.line(vector.x, vector.y, x, y);\r\n        p.fill(0);\r\n        p.strokeWeight(1);\r\n        p.triangle(vector.x, vector.y, x, y, x, vector.y);\r\n        if ((vector.x === x || vector.y === y) && i % 4 === 0) {\r\n          p.ellipse(x, y, p.dist(x, y, vector.x, vector.y));\r\n        }\r\n      }\r\n    });\r\n    if (vectors.filter(v => v.reached).length === vectors.length) {\r\n      p.noLoop();\r\n    }\r\n  };\r\n};\r\n\r\nexport default ({ location }) => (\r\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"Reload page for a different variation.\" />\r\n);\r\n"],"sourceRoot":""}