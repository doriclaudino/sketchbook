{"version":3,"sources":["webpack:///./src/pages/sketch/2018/12/30.js"],"names":["sketch","p","maxSize","minSize","circles","increment","noDrawCount","Circle","distance","this","angle","frameCount","r","constrain","noise","_setXY","x","width","cos","y","height","sin","setDistance","increaseDistance","isOnCanvas","draw","ellipse","setup","createCanvas","random","push","fill","stroke","background","noLoop","forEach","c","noStroke","rect","text","pop","newCircle","strokeWeight","line","some","dist","max","location","path","pathname","description"],"mappings":"mJAGMA,EAAS,SAASC,GACtB,IAAIC,EACAC,EACAC,EAAU,GACVC,EAAY,EACZC,EAAc,EAGZC,EARmB,WASvB,WAAYC,QAAc,IAAdA,MAAW,GACrBC,KAAKD,SAAWA,EAChBC,KAAKC,MAAQT,EAAEU,WAAaN,EAC5BI,KAAKG,EAAIX,EAAEY,UAAUZ,EAAEa,MAAML,KAAKC,OAASR,EAASC,EAASD,GAC7DO,KAAKM,SAbgB,2BAevBA,OAAA,WACEN,KAAKO,EAAIf,EAAEgB,MAAQ,EAAIhB,EAAEiB,IAAIT,KAAKC,OAASD,KAAKD,SAChDC,KAAKU,EAAIlB,EAAEmB,OAAS,EAAInB,EAAEoB,IAAIZ,KAAKC,OAASD,KAAKD,UAjB5B,EAmBvBc,YAAA,SAAYd,GACVC,KAAKD,SAAWA,EAChBC,KAAKM,UArBgB,EAuBvBQ,iBAAA,WACEd,KAAKD,UAAY,EACjBC,KAAKM,UAzBgB,EA2BvBS,WAAA,WACE,OACEf,KAAKO,EAAIP,KAAKG,GACdH,KAAKO,EAAIf,EAAEgB,MAAQR,KAAKG,GACxBH,KAAKU,EAAIV,KAAKG,GACdH,KAAKU,EAAIlB,EAAEmB,OAASX,KAAKG,GAhCN,EAmCvBa,KAAA,WACExB,EAAEyB,QAAQjB,KAAKO,EAAGP,KAAKU,EAAY,EAATV,KAAKG,IApCV,KAwCzBX,EAAE0B,MAAQ,WACR1B,EAAE2B,aAAa,IAAK,KACpB1B,EAAUD,EAAE4B,OAAO5B,EAAEgB,MAAQ,EAAGhB,EAAEgB,MAAQ,GAC1Cd,EAAU,EACVC,EAAQ0B,KAAK,IAAIvB,GACjBN,EAAE8B,KAAK,GACP9B,EAAE+B,OAAO,GACT5B,EAAQ,GAAGQ,EAAIV,EACfE,EAAQ,GAAGqB,QAGbxB,EAAEwB,KAAO,WACPxB,EAAEgC,WAAW,KACT/B,IAAYC,GA/CA,OA+CWG,GACzBL,EAAEiC,SAEJ9B,EAAQ+B,SAAQ,SAAAC,GAAC,OAAIA,EAAEX,UACnBnB,EAnDY,OAoDdL,EAAE6B,OACF7B,EAAEoC,WACFpC,EAAE8B,KAAK,KACP9B,EAAEqC,KAAK,EAAG,EAAG,GAAI,IACjBrC,EAAE8B,KAAK,GACP9B,EAAEsC,KAAQjC,EAAV,QAAwC,GAAI,IAC5CL,EAAEuC,OAEJ,IAAMC,EAAY,IAAIlC,EActB,IAbAkC,EAAUnB,YAAYlB,EAAQ,GAAGQ,EAAI6B,EAAU7B,GAC3CN,EA9DY,OA+DdL,EAAE6B,OACF7B,EAAE+B,OAAO,OACT/B,EAAEyC,aAAa,GACfzC,EAAE0C,KACA1C,EAAEgB,MAAQ,EACVhB,EAAEmB,OAAS,EACXnB,EAAEgB,MAAQ,EAAIhB,EAAEiB,IAAIuB,EAAU/B,OAAST,EAAEmB,OACzCnB,EAAEmB,OAAS,EAAInB,EAAEoB,IAAIoB,EAAU/B,OAAST,EAAEmB,QAE5CnB,EAAEuC,OAGFpC,EAAQwC,MACN,SAAAR,GAAC,OAAInC,EAAE4C,KAAKJ,EAAUzB,EAAGyB,EAAUtB,EAAGiB,EAAEpB,EAAGoB,EAAEjB,GAAKsB,EAAU7B,EAAIwB,EAAExB,MAGpE6B,EAAUlB,mBAERkB,EAAUjB,cACZpB,EAAQ0B,KAAKW,GACTvC,EAAUC,IAASE,GAAa,GACpCC,EAAc,IAEdJ,EAAUD,EAAE6C,IAAI5C,EAAU,GAAKC,GAC/BE,EAAYH,EAAUC,EAAUF,EAAE6C,IAAI,EAAGzC,EAAY,GAAKA,EAC1DC,OAKS,0BAAGyC,EAAH,EAAGA,SAAH,OACb,YAAC,IAAD,CAAc/C,OAAQA,EAAQgD,KAAMD,EAASE,SAAUC,YAAY","file":"component---src-pages-sketch-2018-12-30-js-4534dc8dc1d4adbe88ec.js","sourcesContent":["import React from \"react\";\r\nimport SketchLayout from \"~components/sketch-layout\";\r\n\r\nconst sketch = function(p) {\r\n  let maxSize;\r\n  let minSize;\r\n  let circles = [];\r\n  let increment = 1;\r\n  let noDrawCount = 0;\r\n  let noDrawLimit = 1500;\r\n\r\n  class Circle {\r\n    constructor(distance = 0) {\r\n      this.distance = distance;\r\n      this.angle = p.frameCount / increment;\r\n      this.r = p.constrain(p.noise(this.angle) * maxSize, minSize, maxSize);\r\n      this._setXY();\r\n    }\r\n    _setXY() {\r\n      this.x = p.width / 2 + p.cos(this.angle) * this.distance;\r\n      this.y = p.height / 2 + p.sin(this.angle) * this.distance;\r\n    }\r\n    setDistance(distance) {\r\n      this.distance = distance;\r\n      this._setXY();\r\n    }\r\n    increaseDistance() {\r\n      this.distance += 1;\r\n      this._setXY();\r\n    }\r\n    isOnCanvas() {\r\n      return (\r\n        this.x > this.r &&\r\n        this.x < p.width - this.r &&\r\n        this.y > this.r &&\r\n        this.y < p.height - this.r\r\n      );\r\n    }\r\n    draw() {\r\n      p.ellipse(this.x, this.y, this.r * 2);\r\n    }\r\n  }\r\n\r\n  p.setup = function() {\r\n    p.createCanvas(660, 840);\r\n    maxSize = p.random(p.width / 4, p.width / 3);\r\n    minSize = 5;\r\n    circles.push(new Circle());\r\n    p.fill(0);\r\n    p.stroke(0);\r\n    circles[0].r = maxSize;\r\n    circles[0].draw();\r\n  };\r\n\r\n  p.draw = function() {\r\n    p.background(255);\r\n    if (maxSize === minSize && noDrawCount === noDrawLimit) {\r\n      p.noLoop();\r\n    }\r\n    circles.forEach(c => c.draw());\r\n    if (noDrawCount < noDrawLimit) {\r\n      p.push();\r\n      p.noStroke();\r\n      p.fill(255);\r\n      p.rect(0, 0, 80, 30);\r\n      p.fill(0);\r\n      p.text(`${noDrawCount}/${noDrawLimit}`, 10, 20);\r\n      p.pop();\r\n    }\r\n    const newCircle = new Circle();\r\n    newCircle.setDistance(circles[0].r + newCircle.r);\r\n    if (noDrawCount < noDrawLimit) {\r\n      p.push();\r\n      p.stroke(\"red\");\r\n      p.strokeWeight(1);\r\n      p.line(\r\n        p.width / 2,\r\n        p.height / 2,\r\n        p.width / 2 + p.cos(newCircle.angle) * p.height,\r\n        p.height / 2 + p.sin(newCircle.angle) * p.height\r\n      );\r\n      p.pop();\r\n    }\r\n    while (\r\n      circles.some(\r\n        c => p.dist(newCircle.x, newCircle.y, c.x, c.y) < newCircle.r + c.r\r\n      )\r\n    ) {\r\n      newCircle.increaseDistance();\r\n    }\r\n    if (newCircle.isOnCanvas()) {\r\n      circles.push(newCircle);\r\n      if (maxSize > minSize) increment += 5;\r\n      noDrawCount = 0;\r\n    } else {\r\n      maxSize = p.max(maxSize - 0.1, minSize);\r\n      increment = maxSize > minSize ? p.max(1, increment - 1) : increment;\r\n      noDrawCount++;\r\n    }\r\n  };\r\n};\r\n\r\nexport default ({ location }) => (\r\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"Be patient. Reload page for a different variation.\" />\r\n);\r\n"],"sourceRoot":""}