{"version":3,"sources":["webpack:///./src/lib/addNoise.js","webpack:///./src/pages/sketch/2019/04/14.js"],"names":["addNoise","p","intensity","PTS","width","height","push","i","fill","noStroke","ellipse","randomGaussian","pixelDensity","pop","sketch","w","h","GRID_SIZE","SIZES","grid","Doodad","x","y","size","this","random","arc","triangle","translate","rotate","HALF_PI","PI","beginShape","vertex","endShape","CLOSE","setup","createCanvas","colorMode","HSB","hue","background","floor","xx","yy","visited","draw","concat","filter","overlap","Math","max","s","length","noLoop","location","path","pathname","description"],"mappings":"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","file":"component---src-pages-sketch-2019-04-14-js-2ddce8b0b7e50f4a2af4.js","sourcesContent":["const addNoise = (p, intensity = 0.5) => {\n  const PTS = p.width * p.height * 0.02;\n\n  p.push();\n  for (let i = 0; i < PTS; i++) {\n    p.fill(\n      i % 2\n        ? `rgba(0, 0, 0, ${intensity})`\n        : `rgba(255, 255, 255, ${intensity})`\n    );\n    p.noStroke();\n    p.ellipse(\n      p.randomGaussian(p.width / 2, p.width / 3),\n      p.randomGaussian(p.height / 2, p.height / 3),\n      1 / (p.pixelDensity() / 2)\n    );\n  }\n  p.pop();\n};\n\nexport default addNoise;\n","import React from \"react\";\r\nimport SketchLayout from \"~components/sketch-layout\";\r\nimport addNoise from \"~lib/addNoise\";\r\n\r\nconst sketch = function(p) {\r\n  const GRID_SIZE = 60;\r\n  const SIZES = [1, 2, 3, 5, 8, 13, 21];\r\n\r\n  let grid = [];\r\n  let w;\r\n  let h;\r\n\r\n  class Doodad {\r\n    constructor(x, y, size) {\r\n      this.x = x * GRID_SIZE;\r\n      this.y = y * GRID_SIZE;\r\n      this.size = size * GRID_SIZE;\r\n\r\n      p.random() < 0.3 ? this.arc() : this.triangle();\r\n    }\r\n    arc() {\r\n      p.push();\r\n      p.translate(this.x + this.size / 2, this.y + this.size / 2);\r\n      p.rotate(p.random([0, p.HALF_PI, p.PI, p.HALF_PI + p.PI]));\r\n      p.arc(\r\n        -this.size / 2,\r\n        -this.size / 2,\r\n        this.size * 2,\r\n        this.size * 2,\r\n        0,\r\n        p.HALF_PI\r\n      );\r\n      p.pop();\r\n    }\r\n    triangle() {\r\n      p.push();\r\n      p.translate(this.x + this.size / 2, this.y + this.size / 2);\r\n      p.rotate(p.random([0, p.HALF_PI, p.PI, p.HALF_PI + p.PI]));\r\n      p.beginShape();\r\n      p.vertex(-this.size / 2, -this.size / 2);\r\n      p.vertex(this.size / 2, this.size / 2);\r\n      p.vertex(-this.size / 2, this.size / 2);\r\n      p.endShape(p.CLOSE);\r\n      p.pop();\r\n    }\r\n  }\r\n\r\n  p.setup = function() {\r\n    p.createCanvas(660, 840);\r\n    p.colorMode(p.HSB, 100);\r\n\r\n    const hue = p.random(100);\r\n    p.background(hue, 25, 25);\r\n    p.fill(100 - hue, 50, 75);\r\n\r\n    p.noStroke();\r\n\r\n    w = p.floor(p.width / GRID_SIZE);\r\n    h = p.floor(p.height / GRID_SIZE);\r\n\r\n    for (let xx = 0; xx < w; xx++) {\r\n      grid.push([]);\r\n      for (let yy = 0; yy < h; yy++) {\r\n        grid[xx].push({\r\n          x: xx,\r\n          y: yy,\r\n          visited: false,\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  p.draw = function() {\r\n    const { x, y } = p.random(\r\n      [].concat(...grid).filter(({ visited }) => !visited)\r\n    );\r\n\r\n    if (!grid[x][y].visited) {\r\n      let size = Math.max(...SIZES);\r\n      let overlap;\r\n\r\n      do {\r\n        overlap = false;\r\n        for (let xx = x; xx < size + x; xx++) {\r\n          for (let yy = y; yy < size + y; yy++) {\r\n            if (x + size > w || y + size > h || grid[xx][yy].visited) {\r\n              overlap = true;\r\n            }\r\n          }\r\n        }\r\n        if (overlap) {\r\n          size = Math.max(...SIZES.filter(s => s < size));\r\n        }\r\n      } while (overlap);\r\n\r\n      new Doodad(x, y, size);\r\n\r\n      for (let xx = x; xx < size + x; xx++) {\r\n        for (let yy = y; yy < size + y; yy++) {\r\n          grid[xx][yy].visited = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (![].concat(...grid).filter(({ visited }) => !visited).length) {\r\n      addNoise(p, 0.1);\r\n      p.noLoop();\r\n    }\r\n  };\r\n};\r\n\r\nexport default ({ location }) => (\r\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\r\n);\r\n"],"sourceRoot":""}