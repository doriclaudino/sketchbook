{"version":3,"sources":["webpack:///./src/pages/sketch/2019/05/07.js","webpack:///./src/lib/addNoise.js","webpack:///./src/lib/polarToCartesian.js","webpack:///./src/lib/lerpLine.js"],"names":["sketch","p","w","h","SIZES","gridSize","iterations","grid","Doodad","x","y","size","this","drawFunc","random","drawBackslash","drawSlash","stroke","lerpLine","setup","createCanvas","background","noFill","draw","length","strokeWeight","floor","width","height","xx","push","yy","visited","concat","filter","overlap","Math","max","s","noLoop","location","path","pathname","description","addNoise","intensity","PTS","i","fill","noStroke","ellipse","randomGaussian","pixelDensity","pop","polarToCartesianX","center","angle","distance","cos","polarToCartesianY","sin","polarToCartesianEllipse","centerX","centerY","radiusX","radiusY","asArray","polarToCartesian","x1","y1","x2","y2","rate","showFirstDot","noisy","thisRate","dist","l","point","lerp"],"mappings":"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","file":"component---src-pages-sketch-2019-05-07-js-562631c684ce8d9c5575.js","sourcesContent":["import React from \"react\";\r\nimport SketchLayout from \"~components/sketch-layout\";\r\nimport polarToCartesian from \"~lib/polarToCartesian\";\r\nimport addNoise from \"~lib/addNoise\";\r\nimport lerpLine from \"~lib/lerpLine\";\r\n\r\nconst sketch = function(p) {\r\n  const SIZES = [1, 2, 3, 5, 8];\r\n\r\n  let gridSize = 60;\r\n  let iterations = 3;\r\n  let grid = [];\r\n  let w;\r\n  let h;\r\n\r\n  class Doodad {\r\n    constructor(x, y, size) {\r\n      this.x = x * gridSize;\r\n      this.y = y * gridSize;\r\n      this.size = size * gridSize;\r\n\r\n      this.drawFunc = p.random() < 0.1 ? this.drawBackslash : this.drawSlash;\r\n      p.stroke(p.random() < 0.3 ? 255 : 0);\r\n      this.drawFunc();\r\n    }\r\n    drawSlash() {\r\n      lerpLine(\r\n        p,\r\n        this.x,\r\n        this.y + this.size,\r\n        this.x + this.size,\r\n        this.y,\r\n        p.random()\r\n      );\r\n    }\r\n    drawBackslash() {\r\n      lerpLine(\r\n        p,\r\n        this.x,\r\n        this.y,\r\n        this.x + this.size,\r\n        this.y + this.size,\r\n        p.random()\r\n      );\r\n    }\r\n  }\r\n\r\n  p.setup = function() {\r\n    p.createCanvas(660, 840);\r\n    p.background(128);\r\n    p.noFill();\r\n  };\r\n\r\n  p.draw = function() {\r\n    if (grid.length == 0) {\r\n      p.strokeWeight(gridSize / 3);\r\n\r\n      w = p.floor(p.width / gridSize);\r\n      h = p.floor(p.height / gridSize);\r\n\r\n      for (let xx = 0; xx < w; xx++) {\r\n        grid.push([]);\r\n        for (let yy = 0; yy < h; yy++) {\r\n          grid[xx].push({\r\n            x: xx,\r\n            y: yy,\r\n            visited: false,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    const { x, y } = p.random(\r\n      [].concat(...grid).filter(({ visited }) => !visited)\r\n    );\r\n\r\n    if (!grid[x][y].visited) {\r\n      let size = Math.max(...SIZES);\r\n      let overlap;\r\n\r\n      do {\r\n        overlap = false;\r\n        for (let xx = x; xx < size + x; xx++) {\r\n          for (let yy = y; yy < size + y; yy++) {\r\n            if (x + size > w || y + size > h || grid[xx][yy].visited) {\r\n              overlap = true;\r\n            }\r\n          }\r\n        }\r\n        if (overlap) {\r\n          size = Math.max(...SIZES.filter(s => s < size));\r\n        }\r\n      } while (overlap);\r\n\r\n      new Doodad(x, y, size);\r\n\r\n      for (let xx = x; xx < size + x; xx++) {\r\n        for (let yy = y; yy < size + y; yy++) {\r\n          grid[xx][yy].visited = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (![].concat(...grid).filter(({ visited }) => !visited).length) {\r\n      iterations--;\r\n      if (iterations > 0) {\r\n        gridSize /= 3;\r\n        grid = [];\r\n      } else {\r\n        p.noLoop();\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\nexport default ({ location }) => (\r\n  <SketchLayout sketch={sketch} path={location.pathname} description=\"\" />\r\n);\r\n","const addNoise = (p, intensity = 0.5) => {\n  const PTS = p.width * p.height * 0.02;\n\n  p.push();\n  for (let i = 0; i < PTS; i++) {\n    p.fill(\n      i % 2\n        ? `rgba(0, 0, 0, ${intensity})`\n        : `rgba(255, 255, 255, ${intensity})`\n    );\n    p.noStroke();\n    p.ellipse(\n      p.randomGaussian(p.width / 2, p.width / 3),\n      p.randomGaussian(p.height / 2, p.height / 3),\n      1 / (p.pixelDensity() / 2)\n    );\n  }\n  p.pop();\n};\n\nexport default addNoise;\n","const polarToCartesianX = (center, angle, distance) => {\n  return center + Math.cos(angle) * distance;\n};\nconst polarToCartesianY = (center, angle, distance) => {\n  return center + Math.sin(angle) * distance;\n};\nconst polarToCartesian = (\n  centerX,\n  centerY,\n  angle,\n  distance,\n  asArray = false\n) => {\n  const x = polarToCartesianX(centerX, angle, distance);\n  const y = polarToCartesianY(centerY, angle, distance);\n  return asArray ? [x, y] : { x, y };\n};\nconst polarToCartesianEllipse = (\n  centerX,\n  centerY,\n  angle,\n  radiusX,\n  radiusY,\n  asArray = false\n) => {\n  const x = centerX + Math.cos(angle) * radiusX;\n  const y = centerY + Math.sin(angle) * radiusY;\n  return asArray ? [x, y] : { x, y };\n};\n\nexport { polarToCartesianX, polarToCartesianY, polarToCartesianEllipse };\nexport default polarToCartesian;\n","/**\n * Creates a line of points at a specified interval (the rate)\n *\n * @param {obj} p The current p5.js drawing context\n * @param {*} x1\n * @param {*} y1\n * @param {*} x2\n * @param {*} y2\n * @param {*} rate Number between 0 and 1 to determine how often to draw a point\n * @param {*} showFirstDot Defaults to true\n * @param {*} noisy Defaults to true\n */\nexport default function(\n  p,\n  x1,\n  y1,\n  x2,\n  y2,\n  rate,\n  showFirstDot = true,\n  noisy = true\n) {\n  const thisRate = Math.max(rate, 0.01 / p.dist(x1, y1, x2, y2));\n\n  for (let l = 0; l < 1; l += thisRate) {\n    if (l === 0 && !showFirstDot) continue;\n    if ((noisy && p.random() > l) || !noisy) {\n      p.point(p.lerp(x1, x2, l), p.lerp(y1, y2, l));\n    }\n  }\n}\n"],"sourceRoot":""}